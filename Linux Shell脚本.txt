$ /home/path/script.sh   #使用脚本的完整路径
shell程序读取脚本的首行，查看shebang行是否为#!/bin/bash。它会识别/bin/bash，并在内部以如下命令行执行该脚本：
$ /bin/bash script.sh


当打开一个终端的时候，该终端最初会执行一组命令来定义诸如提示文本、颜色等各类设置。这组命令来自位于用户home目录中的.bashrc脚本
（~/.bashrc)。Bash还维护了一个历史记录文件~/.bash_history，用于保存用户运行过的命令。


另一个可用于终端打印的命令是printf。printf使用的参数和C语言中的printf函数一样。例如：
$printf "Hello wrold"
printf使用引用文本由空格分隔的参数。可以在printf中使用格式化字符串。还可以指定字符串的宽度、左右对齐方式等。在默认的情况下，printf并不像echo命令一样会自动添加换行符，必须在需要的时候手动添加，比如下面的脚本中：
#!/bin/bash
#文件名：printf.sh
printf "%-5s %-10s %-4s\n" No Name Mark
printf "%-5s %-10s %-4.2f\n" 1 Sarath 80.3456
printf "%-5s %-10s %-4.2f\n" 2 James 90.9989
printf "%-5s %-10s %-4.2f\n" 3 Jeff 77.564
会得到如下格式化输出：
No	Name	Mark
1	Sarath	80.35
2	James	91.00
3	Jeff	77.56
%-5s指明了一个格式为左对齐且宽度为5的字符串替代（-表示左对齐）。如果不用-指定对齐方式，
字符串则采用右对齐形式。

echo -n 不换行输出
如果需要使用转义序列，则采用echo -e "包含转义序列的字符串"这种形式。例如：
echo -e "1\t2\t3"
输出：
1	2	3


打印彩色输出
在终端生成彩色输出相当好玩，可以使用转义序列来实现。
每种颜色都有对应的颜色码。比如：重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，
洋红=35，青色=36，白色=37。
要打印彩色文本，可输入如下命令：
echo -e "\e[1;31m This is red text \e[0m"
\e[1;31将颜色设为红色，\e[0m将颜色重新置回。只需要将31替换成李想要的颜色码就可以了。
要设置彩色背景，经常使用的颜色码是：重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，
洋红=45，青色=46，白色=47。
要打印彩色文本，可输入如下命令：
echo -e "\e[1;42m Green Background \e[0m"


获得字符串长度
可以用下面的方法获得变量值的长度：
length=$(#var)
例如：
$ var=1234567890
$ echo ${#var}
20
length就是字符串所包含的字符数


在Bash shell环境中， 可以用let, ( ( ) )和[]执行基本的算数操作，而在进行高级操作时，
expr和bc这两个工具也会非常有用。
let命令可以直接执行基本的算数操作。
当使用let时，变量名之前不需要添加$，例如：
let result=no1+no2
echo $result

自加操作
$ let no1++
自减操作
$ let no1--
简写形式
let no+=6
let no-=6

其它方法
操作符[]的使用方法和let命令类似
result=$[ no1 + no2 ]
在[]中也可以使用$前缀，例如：
result=$[ $no1 + 5 ]

也可以使用( ( ) )，但使用( ( ) )时，变量名之前不需要加上$：
result=$(( no1 + 50 ))

expr同样可以用于基本算数操作：
result=`expr 3 + 4`
result=$(expr $no1 + 5)
以上这些方法只能用于整数运算，而不支持浮点数。


获取终端信息
tput和stty是两款终端处理工具。
获取终端的行数和列数：
tput cols
tput lines

打印出当前终端名：
tput longname

将光标移动到方位（100，100）处：
设置文本样式为粗体：
tput bold
设置下划线的起止：
tput smu1
tput rmu1
删除当前光标位置到行尾的所有内容：
tput ed

在输入密码的时候，不能让输入的内容显示出来，在下面的例子中，我们将看到如何使用stty来实现这一要求：
#!/bin/sh
#Filename: password.sh
echo -e "Enter password: "
stty -echo
read password
stty echo 
echo
echo Password read.
其中，选项-echo禁止将输出发送到终端，而选项echo则允许发送输出。




获取、设置日期和延时

有时候，我们需要检查一组命令所花费的时间，那就可以采用下面的方式：
#!/bin/bash
start=$(date +%s)
commands;
statements;

end=$(date +%s)
difference=$(( end - start))
echo Time taken to execute commands is $difference seconds.
加一种方法则是使用timescriptpath来得到执行脚本所使用的时间


编写以循环方式运行的监视脚本时，设置时间间隔是必不可少的。让我们来看看如何生成延时。
在脚本中生成延时
为了在脚本中推迟一段时间，可以使用sleep:
$ sleep no_of_seconds.
例如，下面的脚本就使用tput和sleep从0开始计数到40：
#!/bin/bash
echo -n Count:
tput sc

count=0;
while true;
do 
if [ $count -lt 40 ];then
	let count++;
	sleep 1;
	tput rc
	tput ed
	echo -n $count;
	else exit 0;
fi
done
在上例中，变量count初始经为0，随后每循环一次便增加1。echo 语句打印出count的值。
我们利用tput sc存储光标位置。在每次循环中，我们通过恢复之前存储的光标位置，在终端
中打印出新的count值。恢复光标位置的命令是tput rc。tput ed清除从当前光标位置到
行尾之间的所有内容，使得旧的count值可以被清除并写入新值。循环内的1秒钟延时是通
过sleep命令来实现的。



调试脚本
调试shell脚本不需要什么特殊工具。Bash本身就包含了一些选项，能够打印出脚本接受的参数和输入。
使用选项-x，启动跟踪调试shell脚本：
$ bash -x script.sh
运行带有-x标志的脚本能打印出所执行的每一行命令以及当前状态。注意，你也可以使用sh -x script。
-x标识将脚本中执行过的每一行都输出到stdout。不过，我们也可以要求只关注脚本某些部分的命令
及参数的打印输出。针对这种情况，可以在脚本中使用set built-in来启用或禁止调试打印。
set -x: 在执行时显示参数和命令
set +x: 禁止调试
set -v: 当命令进行读取时显示输入
set +v: 禁止打印输入
例如：
#!/bin/bash
for i in {1..6}
do
set -x
echo $i
set +x
done
echo "Script executed"
输出如下：
+ echo 1
1
+ set +x
+ echo 2
2
+ set +x
+ echo 3
3
+ set +x
+ echo 4
4
+ set +x
+ echo 5
5
+ set +x
+ echo 6
6
+ set +x
Script executed
在上面的脚本中，仅在-x和+x所限制的区域内，echo $i的调试信息才会被打印出来。
这种调试方法是由Bash的内建功能提供的。它们通常以固定的格式生成调试信息。但是在很多情况下，
我们需要以自定义格式显示调试信息。这可以通过传递_DEBUG环境变量来建立这类调试风格。
请看下面的代码：
#!/bin/bash
function DEBUG()
{
	[ "$_DEBUG" == "on" ] && $@ || :
}
for i in {1..10}
do
	DEBUG echo $i
done
可以将调试功能置为"on"来运行上面的脚本：
$ _DEBUG=on ./script.sh
我们在第一个需要打印调试信息的语句前加上DEBUG。如果没有把_DEBUG=on传递给脚本，那么调试信息
就不会打印出来。在Bash中，命令：':'告诉shell不要进行任何操作。


读取命令返回值（状态）
我们可以按照下面的方式获取命令或函数的返回值：
cmd;
echo $?;
$?会给出命令cmd的返回值。

返回值被称为即出状态。它可用于分析命令执行成功与否。如果命令成功退出，退出状态为0，否则为非0。
我们可以按照下面的方法检测某个命令是否成功结束：
#!/bin/bash
CMD="command" # command指代你要检测退出与否的目标命令
status
$CMD
if [ $? -eq 0 ];
then
echo "$CMD executed successfully"
else
echo "$CMD terminated unsuccessfully"
fi


读取命令序列输出
我们可以用下面的方法读取命令序列的输出：
cmd_output=$(COMMANDS)
这种方法也被称为子shell (subshell)。例如：
cmd_output=$(ls | cat -n)
echo $cmd_output

另一种被称为反引用(back-quote)的方法也可以用于存储命令输出：
cmd_output=`COMMANDS`
例如：
cmd_output=`ls | cat -n`
echo $cmd_output

有很多种方法可以给命令分组。来看看其中的几种
1.利用子shell生成一个独立的进程
子shell本身就是独立的进程。可以使用()操作符来定义一个子shell:
pwd;
(cd /bin; ls);
pwd;
当命令在子shell中执行时，不会对当前shell有任何影响，所有的改变仅限于子shell内。例如，当用cd命令
改变子shell的当前目录时，这种弯不会反映到主shell环境中。
pwd命令打印出工作目录的路径。
cd命令将当前目录更改为给定的目录路径。

2.通过引用子shell的方式保留空格和换行符
假设我们使用子shell或反引用的方法将命令的输出读入一个变量中，
可以将它放入双引号中，以保留空格和换行符。例如：
$ cat text.txt
1
2
3

$ out=$(cat text.txt)
$ echo $out
1 2 3  #丢失了换行符\n
$ echo "$out"
1
2
3



以不按回车键的方式读取字符"n"
下面的语句从输入中读取n个字符并存入变量varibale_name:
read -n number_of_chars varibale_name
例如：
$ read -n 2 var
$ echo $var

read还有很多其他选项。
用不回显(non-echoed)的方式读取密码：
read -s var

显示提示信息：
read -p "Enter input:" var

在特定时限内读取输入：
read -t timeout var

例如：
read -t 2 var  #在2秒内将键入的字符串读入变量var

用定界符结束输入行：
read -d delim_charvar

例如：
$ read -d ":" var
hello: #var被设置为hello

























































































